<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Nebula Touch</title>
    <link rel="shortcut icon" href="asset/Nebula Touch 1.png" type="image/x-icon">
    <style>
        body { margin: 0; overflow: hidden; background-color: #020207; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: rgba(255,255,255,0.8); pointer-events: none; user-select: none; z-index: 10;
        }
        h1 { margin: 0; font-weight: 200; letter-spacing: 1px; font-size: 1.4rem; color: #fff; }
        .status-item { margin-top: 8px; font-size: 0.9rem; display: flex; align-items: center; }
        .indicator { width: 8px; height: 8px; border-radius: 50%; background: #555; margin-right: 8px; transition: background 0.3s; box-shadow: 0 0 5px transparent;}
        .indicator.active { background: #00ff88; box-shadow: 0 0 8px #00ff88; }

        .controls-info {
            margin-top: 20px; padding: 15px;
            background: rgba(20, 20, 30, 0.6);
            border-radius: 8px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1);
        }
        .key { color: #4db8ff; font-weight: 600; }
        #current-shape-display { margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 1.1rem; color: white;}

        #loading-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #4db8ff; font-size: 1.5rem; text-align: center; transition: opacity 0.5s;
        }
        
        #input_video { display: none; }
        #text_helper_canvas { display: none; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Nebula Touch</h1>
        <p>Developed by BAdhon_Deb</p>
        <div class="status-item"><div id="cam-status" class="indicator"></div> Camera Status</div>
        <div class="status-item"><div id="hand-status" class="indicator"></div> Hand Detected</div>
        
        <div class="controls-info">
            <div><span class="key">üëå Pinch (Index+Thumb)</span>: Switch Shape</div>
            <div><span class="key">üñê Open/Close Hand</span>: Expand/Contract</div>
            <div><span class="key">üëã Move Hand</span>: Rotate View</div>
            <div id="current-shape-display">Shape: <b>Initializing...</b></div>
        </div>
    </div>

    <div id="loading-screen">
        Initializing Vision Engine & GPU...<br>
        <span style="font-size:1rem; color:#888;">Please allow camera access when prompted.</span>
    </div>

    <video id="input_video" playsinline></video>
    <canvas id="text_helper_canvas"></canvas>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';

        const PARTICLE_COUNT = 16000; 
        const PARTICLE_SIZE = 0.15;
        const MORPH_SPEED = 0.07; 
        const WORLD_SCALE = 12;

        let scene, camera, renderer, particleSystem;
        let positionsCurrent, positionsTarget, colorsAttribute;
        const clock = new THREE.Clock();
        
        const shapeDefinitions = [
            { type: 'math', name: 'Sphere' },
            { type: 'math', name: 'Heart' },
            { type: 'text', name: 'LABU MITHILA' },
            { type: 'text', name: 'I L O V E U' },
            { type: 'math', name: 'Rose' },
            { type: 'text', name: 's o r r y y y y y y y y y y y ü•∫' },
            { type: 'text', name: 'Cholly' },
            { type: 'math', name: 'TorusKnot' }
        ];
        let currentShapeIndex = 0;
        const textPointCache = {}; 
        let isHandDetected = false;
        let pinchDebounce = false; 
        let expansionFactor = 1.0; 
        let rotationTarget = { x: 0, y: 0 };
        let hueCycleOffset = 0;

        async function init() {
            initThreeJS();
            
            await applyShapeByIndex(currentShapeIndex);
            
            initMediaPipe();
            
            animate();
        }


        function initThreeJS() {
            const canvas = document.createElement('canvas');
            document.body.appendChild(canvas);

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020207, 0.025);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 

            const geometry = new THREE.BufferGeometry();
            positionsCurrent = new Float32Array(PARTICLE_COUNT * 3);
            positionsTarget = new Float32Array(PARTICLE_COUNT * 3);
            colorsAttribute = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positionsCurrent[i3] = (Math.random() - 0.5) * 100;
                positionsCurrent[i3 + 1] = (Math.random() - 0.5) * 100;
                positionsCurrent[i3 + 2] = (Math.random() - 0.5) * 100;

                const color = new THREE.Color();
                color.setHSL((i/PARTICLE_COUNT) * 0.5 + 0.5, 0.8, 0.5);
                colorsAttribute[i3] = color.r;
                colorsAttribute[i3+1] = color.g;
                colorsAttribute[i3+2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positionsCurrent, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorsAttribute, 3));

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.85
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }


        async function applyShapeByIndex(index) {
            const shapeDef = shapeDefinitions[index];
            document.getElementById('current-shape-display').innerHTML = `Shape: <b style="color:#00ff88">${shapeDef.name}</b>`;
            
            if (shapeDef.type === 'text') {
               await calculateTextTargets(shapeDef.name);
            } else {
               calculateMathTargets(shapeDef.name);
            }
        }

        function calculateTextTargets(textStr) {
            if(textPointCache[textStr]) {
                 mapPointsToTargets(textPointCache[textStr]);
                 return Promise.resolve();
            }

            return new Promise((resolve) => {
                const canvas = document.getElementById('text_helper_canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                
                canvas.width = 400;
                canvas.height = 200;
                ctx.fillStyle = '#000000'; ctx.fillRect(0,0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 50px "Segoe UI Emoji", "Apple Color Emoji", sans-serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(textStr, canvas.width/2, canvas.height/2);

                const imageData = ctx.getImageData(0,0, canvas.width, canvas.height).data;
                const foundPoints = [];
                for(let y=0; y < canvas.height; y += 2) { 
                    for(let x=0; x < canvas.width; x += 2) {
                        const redIndex = (y * canvas.width + x) * 4;
                        if(imageData[redIndex] > 128) { 
                            foundPoints.push({
                                x: (x / canvas.width - 0.5) * WORLD_SCALE * 2.5, 
                                y: -(y / canvas.height - 0.5) * WORLD_SCALE * 1.2, 
                                z: (Math.random() - 0.5) * 1.5
                            });
                        }
                    }
                }
                mapPointsToTargets(foundPoints);
                resolve();
            });
        }
        function mapPointsToTargets(pointsArray) {
            if(pointsArray.length === 0) return;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const pt = pointsArray[i % pointsArray.length];
                positionsTarget[i3] = pt.x;
                positionsTarget[i3 + 1] = pt.y;
                positionsTarget[i3 + 2] = pt.z;
            }
        }
        function calculateMathTargets(shapeName) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let x, y, z;
                const u = Math.random(); 
                const v = Math.random();
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;

                switch(shapeName) {
                    case 'Sphere':
                        const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                        const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                        x = WORLD_SCALE * Math.cos(theta) * Math.sin(phi);
                        y = WORLD_SCALE * Math.sin(theta) * Math.sin(phi);
                        z = WORLD_SCALE * Math.cos(phi);
                        break;

                    case 'Heart':
                        const rH = WORLD_SCALE * 0.09;
                        const hx = 16 * Math.pow(Math.sin(t), 3);
                        const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        x = hx * rH;
                        y = hy * rH;
                        z = (Math.random() - 0.5) * WORLD_SCALE * 0.5;
                        break;

                    case 'Rose':
                        const k = 4;
                        const thetaRose = (i / PARTICLE_COUNT) * Math.PI * 2 * 12;
                        const radiusRose = WORLD_SCALE * Math.cos(k * thetaRose);
                        x = radiusRose * Math.cos(thetaRose);
                        y = radiusRose * Math.sin(thetaRose);
                        z = (i / PARTICLE_COUNT) * WORLD_SCALE * 2 - WORLD_SCALE;
                        break;

                     case 'TorusKnot':
                        const tk = (i / PARTICLE_COUNT) * Math.PI * 2 * 3;
                        const p=2, q=3;
                        const rTk = WORLD_SCALE * 0.5 * (2 + Math.cos(q*tk));
                        x = rTk * Math.cos(p*tk);
                        y = rTk * Math.sin(p*tk);
                        z = WORLD_SCALE * 0.8 * Math.sin(q*tk);
                        x += (Math.random()-0.5); y+= (Math.random()-0.5); z+= (Math.random()-0.5);
                        break;
                }
                positionsTarget[i3] = x;
                positionsTarget[i3 + 1] = y;
                positionsTarget[i3 + 2] = z;
            }
        }
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            particleSystem.rotation.x += (rotationTarget.y - particleSystem.rotation.x) * 0.05;
            particleSystem.rotation.y += (rotationTarget.x - particleSystem.rotation.y) * 0.05;
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                let tx = positionsTarget[i3];
                let ty = positionsTarget[i3 + 1];
                let tz = positionsTarget[i3 + 2];
                tx *= expansionFactor; ty *= expansionFactor; tz *= expansionFactor;
                tx += Math.sin(time * 1.5 + i * 0.01) * 0.2;
                ty += Math.cos(time * 1.7 + i * 0.012) * 0.2;
                positions[i3] += (tx - positions[i3]) * MORPH_SPEED;
                positions[i3 + 1] += (ty - positions[i3 + 1]) * MORPH_SPEED;
                positions[i3 + 2] += (tz - positions[i3 + 2]) * MORPH_SPEED;
                const hue = (i / PARTICLE_COUNT * 0.3 + time * 0.05 + hueCycleOffset) % 1;
                const lightness = isHandDetected ? 0.6 : 0.4;
                
                const color = new THREE.Color();
                color.setHSL(hue, 0.9, lightness);
                colors[i3] = color.r;
                colors[i3+1] = color.g;
                colors[i3+2] = color.b;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }
        function initMediaPipe() {
            const videoElement = document.getElementById('input_video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            
            cameraUtils.start().then(() => {
                document.getElementById('cam-status').classList.add('active');
                const loading = document.getElementById('loading-screen');
                loading.style.opacity = 0;
                setTimeout(() => loading.remove(), 1000);
            }).catch(e => {
                document.getElementById('loading-screen').innerHTML = "Camera Error: Allow access and reload (HTTPS required).";
            });
        }

        function onHandResults(results) {
            const handUi = document.getElementById('hand-status');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                if(!isHandDetected) {
                     isHandDetected = true;
                     handUi.classList.add('active');
                }
                
                const lm = results.multiHandLandmarks[0];
                const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                const PINCH_THRESHOLD = 0.05;

                if (pinchDist < PINCH_THRESHOLD) {
                    if (!pinchDebounce) {
                        pinchDebounce = true;
                        currentShapeIndex = (currentShapeIndex + 1) % shapeDefinitions.length;
                        applyShapeByIndex(currentShapeIndex);
                        hueCycleOffset += 0.3;
                    }
                } else {
                    pinchDebounce = false;
                }
                const spreadDist = Math.hypot(lm[4].x - lm[20].x, lm[4].y - lm[20].y);
                expansionFactor = 0.5 + (spreadDist * 3.5);
                expansionFactor = Math.max(0.5, Math.min(2.5, expansionFactor));
                rotationTarget.x = -(lm[5].x - 0.5) * 3;
                rotationTarget.y = -(lm[5].y - 0.5) * 2;

            } else {
                // Hand lost
                if(isHandDetected) {
                    isHandDetected = false;
                    handUi.classList.remove('active');
                    expansionFactor = 1.0;
                }
            }
        }
        init();
    </script>
</body>
</html>