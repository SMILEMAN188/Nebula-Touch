<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Particle Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: rgba(255,255,255,0.9);
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; text-transform: uppercase; font-size: 1.2rem; }
        .status { font-size: 0.85rem; color: #888; margin-top: 5px; }
        .active-status { color: #00ff88; text-shadow: 0 0 10px rgba(0,255,136,0.5); }
        
        .controls {
            margin-top: 15px;
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 250px;
        }
        .controls div { margin-bottom: 5px; font-size: 0.9rem; }
        .key { color: #4db8ff; font-weight: bold; }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            text-align: center;
            transition: opacity 0.5s;
        }

        /* Hidden elements required for processing */
        #input_video { display: none; }
        #text_canvas { display: none; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Particle Morph</h1>
        <div class="status">Camera: <span id="cam-status">Initializing...</span></div>
        <div class="status">Hand Tracking: <span id="hand-status">Waiting...</span></div>
        <div class="controls">
            <div><span class="key">üëå Pinch</span> to Switch Shape</div>
            <div><span class="key">üñê Open/Close</span> to Expand</div>
            <div><span class="key">üëã Move</span> to Rotate</div>
            <div style="margin-top:10px; border-top:1px solid #333; paddingTop:5px;">
                Current: <strong id="shape-name" style="color:white">Sphere</strong>
            </div>
        </div>
    </div>

    <div id="loading">Initialize Camera & AI...<br><span style="font-size:1rem; color:#888;">Please allow camera access</span></div>

    <video id="input_video"></video>
    <canvas id="text_canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 20000;
        const PARTICLE_SIZE = 0.12;
        const MORPH_SPEED = 0.08;
        const WORLD_SCALE = 12;

        // --- STATE ---
        let scene, camera, renderer, particles;
        let positionsOriginal, positionsTarget;
        let colorsAttribute;
        let clock = new THREE.Clock();
        
        // Shapes
        const shapes = ['Sphere', 'Heart', 'M + B', 'Rose', 'SolarSystem', 'Torus'];
        let currentShapeIndex = 0;
        let textPoints = []; // Stores the "M + B" coordinates

        // Interaction
        let isHandDetected = false;
        let pinchTriggered = false;
        let expansionFactor = 1.0;
        let rotationTarget = { x: 0, y: 0 };
        let hueOffset = 0;

        init();

        async function init() {
            initThree();
            // Pre-calculate text shape before starting animation
            await generateTextParticles("M + B"); 
            calculateTargetPositions(shapes[0]);
            initMediaPipe();
            animate();
        }

        // --- THREE.JS SETUP ---
        function initThree() {
            const canvas = document.createElement('canvas');
            canvas.id = 'webgl-canvas';
            document.body.appendChild(canvas);

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            positionsTarget = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Random Start
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

                // Initial Colors
                const color = new THREE.Color();
                color.setHSL(Math.random(), 0.7, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Material
            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize);
        }

        // --- TEXT GENERATION HELPERS ---
        function generateTextParticles(text) {
            return new Promise((resolve) => {
                const canvas = document.getElementById('text_canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 100;

                ctx.fillStyle = '#000000';
                ctx.fillRect(0,0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 50px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, canvas.width/2, canvas.height/2);

                const data = ctx.getImageData(0,0, canvas.width, canvas.height).data;
                textPoints = [];

                // Scan pixel data
                for(let y=0; y < canvas.height; y += 2) {
                    for(let x=0; x < canvas.width; x += 2) {
                        const alpha = data[(y * canvas.width + x) * 4]; // Check R channel (white text)
                        if(alpha > 128) {
                            textPoints.push({
                                x: (x / canvas.width - 0.5) * 25, // Scale to world
                                y: -(y / canvas.height - 0.5) * 12,
                                z: 0
                            });
                        }
                    }
                }
                resolve();
            });
        }

        // --- MATH FOR SHAPES ---
        function calculateTargetPositions(shape) {
            document.getElementById('shape-name').innerText = shape;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let x, y, z;

                if (shape === 'Sphere') {
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    x = WORLD_SCALE * Math.cos(theta) * Math.sin(phi);
                    y = WORLD_SCALE * Math.sin(theta) * Math.sin(phi);
                    z = WORLD_SCALE * Math.cos(phi);
                } 
                else if (shape === 'Heart') {
                    const t = Math.random() * Math.PI * 2;
                    const r = WORLD_SCALE * 0.08; 
                    // 2D Heart curve projected
                    let hx = 16 * Math.pow(Math.sin(t), 3);
                    let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    // Add volume
                    x = hx * r;
                    y = hy * r;
                    z = (Math.random() - 0.5) * WORLD_SCALE * 0.5;
                }
                else if (shape === 'M + B') {
                    // Map particles to text points, recycling points if particles > points
                    const pt = textPoints[i % textPoints.length];
                    x = pt.x;
                    y = pt.y;
                    z = pt.z + (Math.random() - 0.5) * 2; // Add little jitter depth
                }
                else if (shape === 'Rose') {
                    // 3D Rose (Rhodonea)
                    const k = 4; // petals
                    const theta = (i / PARTICLE_COUNT) * Math.PI * 2 * 10;
                    const r = WORLD_SCALE * Math.cos(k * theta);
                    x = r * Math.cos(theta);
                    y = r * Math.sin(theta);
                    z = (i / PARTICLE_COUNT) * WORLD_SCALE - (WORLD_SCALE/2); // Spiral depth
                }
                else if (shape === 'SolarSystem') {
                    // 20% Sun, 80% Ring
                    if(i < PARTICLE_COUNT * 0.2) {
                        const u = Math.random();
                        const v = Math.random();
                        const theta = 2 * Math.PI * u;
                        const phi = Math.acos(2 * v - 1);
                        const r = WORLD_SCALE * 0.25;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = WORLD_SCALE * (0.8 + Math.random() * 1.5);
                        x = dist * Math.cos(angle);
                        z = dist * Math.sin(angle);
                        y = (Math.random() - 0.5) * 0.5;
                    }
                }
                else if (shape === 'Torus') {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    const R = WORLD_SCALE * 0.8; 
                    const r = WORLD_SCALE * 0.3;
                    x = (R + r * Math.cos(v)) * Math.cos(u);
                    y = (R + r * Math.cos(v)) * Math.sin(u);
                    z = r * Math.sin(v);
                }

                positionsTarget[i3] = x;
                positionsTarget[i3 + 1] = y;
                positionsTarget[i3 + 2] = z;
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;

            // Global Rotation via Hand
            particles.rotation.x += (rotationTarget.y - particles.rotation.x) * 0.05;
            particles.rotation.y += (rotationTarget.x - particles.rotation.y) * 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                // Get base target
                let tx = positionsTarget[i3];
                let ty = positionsTarget[i3 + 1];
                let tz = positionsTarget[i3 + 2];

                // Apply Expansion (Hand Spread)
                tx *= expansionFactor;
                ty *= expansionFactor;
                tz *= expansionFactor;

                // Add Noise/Breathing
                tx += Math.sin(time + i) * 0.05;
                ty += Math.cos(time + i * 0.5) * 0.05;

                // Linear Interpolation (Morph)
                positions[i3] += (tx - positions[i3]) * MORPH_SPEED;
                positions[i3 + 1] += (ty - positions[i3 + 1]) * MORPH_SPEED;
                positions[i3 + 2] += (tz - positions[i3 + 2]) * MORPH_SPEED;

                // Dynamic Color
                const hue = (i / PARTICLE_COUNT + time * 0.05 + hueOffset) % 1;
                const color = new THREE.Color();
                color.setHSL(hue, 0.9, 0.6);
                colors[i3] = color.r;
                colors[i3+1] = color.g;
                colors[i3+2] = color.b;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- MEDIAPIPE LOGIC ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input_video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            hands.onResults(onHandResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading').style.opacity = 0;
                    setTimeout(()=> document.getElementById('loading').remove(), 500);
                    document.getElementById('cam-status').innerText = "Active";
                    document.getElementById('cam-status').classList.add("active-status");
                });
        }

        function onHandResults(results) {
            const handStatus = document.getElementById('hand-status');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                if(!isHandDetected) {
                    handStatus.innerText = "Detected";
                    handStatus.classList.add("active-status");
                    isHandDetected = true;
                }
                
                const lm = results.multiHandLandmarks[0];

                // 1. PINCH DETECTION (Index Tip 8, Thumb Tip 4)
                const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                if (pinchDist < 0.05) {
                    if (!pinchTriggered) {
                        // Next Shape
                        currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                        calculateTargetPositions(shapes[currentShapeIndex]);
                        pinchTriggered = true;
                    }
                    hueOffset += 0.02; // Fast color cycle when pinching
                } else {
                    pinchTriggered = false;
                }

                // 2. EXPANSION (Palm Spread)
                // Distance between Thumb Tip (4) and Pinky Tip (20)
                const spread = Math.hypot(lm[4].x - lm[20].x, lm[4].y - lm[20].y);
                // Map spread 0.1->0.4 to expansion 0.5->2.0
                expansionFactor = 0.5 + (spread * 4); 

                // 3. ROTATION (Palm Center - approximated by index knuckle 5)
                // Normalize coordinates -1 to 1
                const nx = (lm[5].x - 0.5) * 4; 
                const ny = (lm[5].y - 0.5) * 4;
                rotationTarget.x = nx;
                rotationTarget.y = ny;

            } else {
                if(isHandDetected) {
                    handStatus.innerText = "Searching...";
                    handStatus.classList.remove("active-status");
                    isHandDetected = false;
                    expansionFactor = 1.0; // Reset
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>