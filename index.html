

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Particle Morph</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: sans-serif;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }
        /* UI Overlays */
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff88;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 0 5px #000;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
        }
        .status-dot {
            height: 10px; width: 10px;
            background-color: #bbb;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .status-dot.active { background-color: #00ff88; box-shadow: 0 0 8px #00ff88; }
        /* Hide the raw video feed */
        #input_video { display: none; }
        /* Hide the text canvas */
        #textCanvas { display: none; }
    </style>
</head>
<body>
    <div id="loading">Initializing Vision & GPU...<br><small>Please allow camera access</small></div>
    
    <div id="ui-overlay">
        <h2>Quantum Particles</h2>
        <div><span id="cam-status" class="status-dot"></span> Camera Active</div>
        <div><span id="hand-status" class="status-dot"></span> Hand Detected</div>
        <p>Current Shape: <b id="shape-name" style="color:white">Sphere</b></p>
        <small>
            üëå Pinch (Index+Thumb) to switch shape.<br>
            üñê Open/Close hand to expand/contract.<br>
            üëã Move hand to rotate.
        </small>
    </div>

    <video id="input_video" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="textCanvas" width="200" height="100"></canvas>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>


    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 18000;
        const PARTICLE_SIZE = 0.12;
        const MORPH_SPEED = 0.06; // Lower = smoother, slower transitions
        const WORLD_SCALE = 15;

        // GLOBALS
        let scene, camera, renderer, particleSystem;
        let positionsCurrent, positionsTarget, colorsAttr;
        let clock = new THREE.Clock();
        let shapeFuncs = {};
        let textPoints = []; // Store calculated points for text

        // INTERACTION STATE
        let currentShapeIndex = 0;
        const shapeOrder = ['Sphere', 'Heart', 'M + B', 'Rose', 'SolarSystem', 'Fireworks'];
        let handDetected = false;
        let pinchDebounce = false;
        let expansionFactor = 1.0; // controlled by hand spread
        let rotationTarget = { x: 0, y: 0 };
        let hueOffset = 0;


        // =========================================
        // --- INITIALIZATION ---
        // =========================================
        initThree();
        preCalculateTextPoints("M + B");
        initShapeFunctions();
        calculateNextTarget(shapeOrder[currentShapeIndex]); // Initial shape
        initMediaPipe();
        animate();


        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // Add some subtle fog for depth
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // --- Particle System Setup ---
            const geometry = new THREE.BufferGeometry();
            positionsCurrent = new Float32Array(PARTICLE_COUNT * 3);
            positionsTarget = new Float32Array(PARTICLE_COUNT * 3);
            colorsAttr = new Float32Array(PARTICLE_COUNT * 3);

            // Initial Explosion state
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positionsCurrent[i * 3] = (Math.random() - 0.5) * 100;
                positionsCurrent[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positionsCurrent[i * 3 + 2] = (Math.random() - 0.5) * 100;

                const color = new THREE.Color();
                color.setHSL(i / PARTICLE_COUNT, 0.8, 0.5);
                colorsAttr[i*3] = color.r; colorsAttr[i*3+1] = color.g; colorsAttr[i*3+2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positionsCurrent, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorsAttr, 3));

            // Using PointsMaterial with additive blending for a glowing effect
            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8,
                depthWrite: false
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            window.addEventListener('resize', onWindowResize);
        }


        // =========================================
        // --- SHAPE MATHEMATICS & GENERATION ---
        // =========================================

        // Helper to sample text onto a canvas and find points
        function preCalculateTextPoints(text) {
            const canvas = document.getElementById('textCanvas');
            const ctx = canvas.getContext('2d', {willReadFrequently: true});
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            textPoints = [];
            for (let y = 0; y < canvas.height; y+=2) { // skip pixels for density control
                for (let x = 0; x < canvas.width; x+=2) {
                    const alpha = imageData.data[(y * canvas.width + x) * 4 + 3];
                    if (alpha > 128) {
                        // Normalize to roughly -1 to 1 range
                        const nx = (x / canvas.width - 0.5) * 2;
                        const ny = -(y / canvas.height - 0.5) * 2; // flip Y
                        textPoints.push({x: nx * WORLD_SCALE * 1.5, y: ny * WORLD_SCALE * 0.8, z: 0});
                    }
                }
            }
        }


        function initShapeFunctions() {
            shapeFuncs = {
                'Sphere': (i) => {
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    return {
                        x: WORLD_SCALE * Math.cos(theta) * Math.sin(phi),
                        y: WORLD_SCALE * Math.sin(theta) * Math.sin(phi),
                        z: WORLD_SCALE * Math.cos(phi)
                    };
                },
                'Heart': (i) => {
                    // Parametric heart equations
                    const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                    const scale = WORLD_SCALE * 0.08;
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    // Add depth based on index to make it 3D volume
                    const z = (Math.random() - 0.5) * scale * 4; 
                    return { x: x * scale, y: y * scale, z: z };
                },
                 'M + B': (i) => {
                     // Recycle points if we have more particles than text pixels
                     const pt = textPoints[i % textPoints.length];
                     // Add slight jitter z-depth
                     return { x: pt.x, y: pt.y, z: pt.z + (Math.random()-0.5)*2 };
                 },
                'Rose': (i) => {
                    // Rhodonea Curve (k=4 for 8 petals)
                    const k = 4;
                    const t = (i / PARTICLE_COUNT) * Math.PI * 2 * 4; // *4 repeats curve to fill volume
                    const radius = WORLD_SCALE * Math.cos(k * t);
                    // Varying Z to create a "bouquet" depth
                    const zDepth = (i / PARTICLE_COUNT) * WORLD_SCALE * 0.5; 
                    return {
                        x: radius * Math.cos(t),
                        y: radius * Math.sin(t),
                        z: zDepth - (WORLD_SCALE*0.25)
                    };
                },
                'SolarSystem': (i) => {
                    // 20% Sun, rest Rings
                    if (i < PARTICLE_COUNT * 0.2) {
                        // Sun Sphere
                        const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT*0.2));
                        const theta = Math.sqrt(PARTICLE_COUNT*0.2 * Math.PI) * phi;
                        const sunScale = WORLD_SCALE * 0.3;
                        return {
                            x: sunScale * Math.cos(theta) * Math.sin(phi),
                            y: sunScale * Math.sin(theta) * Math.sin(phi),
                            z: sunScale * Math.cos(phi)
                        };
                    } else {
                        // Rings / Discs
                        const ringIndex = i - PARTICLE_COUNT * 0.2;
                        const t = (ringIndex / (PARTICLE_COUNT*0.8)) * Math.PI * 2 * 20; // wrap around many times
                        // Distribute radius to create a disc
                        const radius = WORLD_SCALE * (0.5 + Math.random() * 1.5);
                        return {
                            x: radius * Math.cos(t),
                            z: radius * Math.sin(t),
                            y: (Math.random() - 0.5) * 0.5 // Thin disc
                        };
                    }
                },
                'Fireworks': (i) => {
                    // A static burst shape
                    const t = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    // Power law distribution for burst effect (more in center, some far out)
                    const radius = WORLD_SCALE * Math.pow(Math.random(), 2) * 2; 
                    return {
                        x: radius * Math.sin(phi) * Math.cos(t),
                        y: radius * Math.sin(phi) * Math.sin(t),
                        z: radius * Math.cos(phi)
                    };
                }
            };
        }

        // Populates the positionsTarget array based on the selected shape name
        function calculateNextTarget(shapeName) {
            const func = shapeFuncs[shapeName];
            if (!func) return;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pos = func(i);
                positionsTarget[i * 3] = pos.x;
                positionsTarget[i * 3 + 1] = pos.y;
                positionsTarget[i * 3 + 2] = pos.z;
            }
            
            document.getElementById('shape-name').textContent = shapeName;
        }


        // =========================================
        // --- ANIMATION LOOP ---
        // =========================================
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;

            // Apply overall rotation based on hand position smoothed
            particleSystem.rotation.x += (rotationTarget.x - particleSystem.rotation.x) * 0.05;
            particleSystem.rotation.y += (rotationTarget.y - particleSystem.rotation.y) * 0.05;

            // Advance hue if pinching held (creates rapid color cycling effect)
            if(pinchDebounce) hueOffset += 0.02;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix3 = i * 3;

                // --- 1. Calculate Modified Target ---
                // Apply expansion factor controlled by hand spread
                // Add some organic noise movement based on time and index
                const noiseX = Math.sin(time * 1.5 + i * 0.1) * 0.2;
                const noiseY = Math.cos(time * 1.7 + i * 0.12) * 0.2;
                const noiseZ = Math.sin(time * 1.9 + i * 0.15) * 0.2;

                const targetX = positionsTarget[ix3] * expansionFactor + noiseX;
                const targetY = positionsTarget[ix3 + 1] * expansionFactor + noiseY;
                const targetZ = positionsTarget[ix3 + 2] * expansionFactor + noiseZ;

                // --- 2. Morphing (Linear Interpolation) ---
                // Move current position towards target position
                positions[ix3] += (targetX - positions[ix3]) * MORPH_SPEED;
                positions[ix3 + 1] += (targetY - positions[ix3 + 1]) * MORPH_SPEED;
                positions[ix3 + 2] += (targetZ - positions[ix3 + 2]) * MORPH_SPEED;


                // --- 3. Dynamic Coloring ---
                // Base color on particle index + time + pinch offset
                const hue = ((i / PARTICLE_COUNT) * 0.5 + time * 0.05 + hueOffset) % 1.0;
                // Lightness increases if hand is detected
                const lightness = handDetected ? 0.6 : 0.4;
                
                const color = new THREE.Color();
                color.setHSL(hue, 0.8, lightness);
                colors[ix3] = color.r;
                colors[ix3+1] = color.g;
                colors[ix3+2] = color.b;
            }

            // Tell Three.js the data has changed
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }


        // =========================================
        // --- COMPUTER VISION (MediaPipe Hands) ---
        // =========================================
        function initMediaPipe() {
            const videoElement = document.getElementById('input_video');
            const camStatus = document.getElementById('cam-status');
            const handStatusUi = document.getElementById('hand-status');

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1, // 0 for speed, 1 for accuracy
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                document.getElementById('loading').style.display = 'none';
                camStatus.classList.add('active');

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handDetected = true;
                    handStatusUi.classList.add('active');
                    
                    const landmarks = results.multiHandLandmarks[0];
                    processGestures(landmarks);
                } else {
                    handDetected = false;
                    handStatusUi.classList.remove('active');
                    // Reset interactions if hand is lost
                    expansionFactor = 1.0;
                    pinchDebounce = false; 
                    rotationTarget = { x: 0, y: 0 };
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640, // Lower res input is faster for processing
                height: 480
            });
            cameraUtils.start();
        }

        function processGestures(landmarks) {
            // landmarks is an array of 21 {x, y, z} points normalized 0.0-1.0

            // --- Gesture 1: Pinch Detection (Thumb tip #4, Index tip #8) ---
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            // Simple Euclidean distance squared (faster than sqrt)
            const pinchDistSq = Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2);
            const PINCH_THRESHOLD_SQ = 0.002; // Adjusted experimentally

            if (pinchDistSq < PINCH_THRESHOLD_SQ) {
                if (!pinchDebounce) {
                    // Trigger shape switch only once per pinch closure
                    currentShapeIndex = (currentShapeIndex + 1) % shapeOrder.length;
                    calculateNextTarget(shapeOrder[currentShapeIndex]);
                    pinchDebounce = true;
                }
            } else {
                pinchDebounce = false;
            }


            // --- Gesture 2: Hand Spread (Expansion) ---
            // Calculate average distance of fingertips to palm center (#0 or #9)
            const palmCenter = landmarks[9];
            const fingerTips = [4, 8, 12, 16, 20];
            let totalDist = 0;
            fingerTips.forEach(idx => {
                 totalDist += Math.sqrt(Math.pow(landmarks[idx].x - palmCenter.x, 2) + Math.pow(landmarks[idx].y - palmCenter.y, 2));
            });
            const avgSpread = totalDist / 5;
            // Normalize spread experimentally: closed fist ~0.1, open hand ~0.35
            // Map to expansion factor range 0.5 (contracted) to 2.0 (expanded)
            expansionFactor = Math.max(0.5, Math.min(2.5, (avgSpread - 0.1) * 6));

            
            // --- Gesture 3: Rotation based on hand position in frame ---
            // Map x/y (0-1) to rotation radians (-0.5 to 0.5)
            // Invert X so moving hand right rotates right
            rotationTarget.y = (landmarks[9].x - 0.5) * 2.0; 
            rotationTarget.x = (landmarks[9].y - 0.5) * 1.0;
        }


        // --- UTILS ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>